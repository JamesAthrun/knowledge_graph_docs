# 后端扩展功能设计

## 用户权限

### 想法

- 参照linux用户权限的思想，考虑知识图谱本身的特性，权限只有读写两类，用户群是拥有者，群体，所有人
- 权限保存模仿chmod的777，保存为xxx（拥有者，群体，所有人），x属于[0, 1, 2]因为可写一定要可读，所以0表示无权限，1为读，2为读写，

### 实现流程

- 创建一张group表，包含groupid，name，description信息
- 创建一张user-group表，作为外键存储
- 知识图谱表新增groupid，userid，authority三个字段，保存群体，拥有者和权限信息

## 变更版本控制

### 想法

- 具体实现方式参考了git快照机制和存储机制
  - https://blog.csdn.net/ystyaoshengting/article/details/104028633
  - https://www.zhihu.com/question/27680108
  - 修改：由每个数据保存版本号，而不是由版本控制保存数据的指针
- 考虑到分支这一个要素在知识图谱编辑方面并没有太大意义，并且合并写起来太麻烦（划掉），删除这部分功能
- 单分支回退功能使用增量保存来实现
- 将每一张知识图谱看作是一个仓库，每次变更可以包含多个增删操作，但必须针对一张知识图谱，只记录增加/删除操作
- 用户进行增删后不立即提交，现将变更保存在暂存区（参考git add），用户确认修改，写入修改信息后可以上传修改（参考git commit -m），在修改记录表格增加一项数据，并在知识图谱数据区更新所有数据的版本号（详情见下）

### 实现流程

- 增加变更表，包含修改版本号，修改的tableid，修改的用户id，修改时间，修改commit信息
- 数据表（triple，entity）新增两个数据段：起始版本号，最终版本号
- 知识图谱总表为每一个知识图谱新建一个数据段保存当前版本号
- 代码要修改数据检索方法，不再是检索全表，而是根据版本号检索表中当前的数据，解释如下

### 详解/举例

- 假设当前版本号为x，更新后版本号为x+1
  - 增加数据就是在triple或者entity中插入一条新的数据，并更新它的起始版本号和最终版本号都是x+1
  - 删除数据就是暂时标记这行数据
  - 修改数据就是进行删除然后新增两步
  - 提交后，增加的数据和删除的数据都不变，其他没有改变的数据将最终版本号更新为x+1
- 假设当前版本号为x
  - 查询时，只需要查询最终版本号为x的数据，其他都是被舍弃的
  - 如果要回退到x-5的版本，只需要遍历全表，将开始版本号大于x-5的删除，最终版本号大于x-5的改为x-5，就实现了版本回退
- 如果两个用户同时变更，后变更的人如果当前版本号小于服务器的最新版本号，则要强制更新后再上传，不过不做合并（太麻烦

### 可能的问题

- 版本不断更新数据会不断增加，没有做压缩和其他处理
- 回退版本后不能撤销回退，会删除回退之前的新数据，但关系应该不大

